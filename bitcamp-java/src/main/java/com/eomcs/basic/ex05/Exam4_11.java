package com.eomcs.basic.ex05;

// # 비트 이동 연산자 : 비트 이동의 유효 범위
//
public class Exam4_11 {
  public static void main(String[] args) {
    System.out.println(3 << 1);
    //   0000000000 00000000 00000000 000000011 = 3
    // 0|000000000 00000000 00000000 000000011x = 비트이동
    //   00000000 00000000 00000000 0000000110 = 6

    System.out.println(3 << 33);
    System.out.println(3 << 65);
    System.out.println(3 << 97);
    
    // 3에 33비트를 이동하나, 65비트를 이동하나, 97 비트를 이동하나
    // 같은 값이 나오는 이유?
    // => int타입의 값에 대해 비트 이동을 할 때는 0~ 31 까지만 유효하다.
    //    만약 31을 넘는 경우 32로 나눈 나머지 값을 비통 이동으로 간주한다.
    // => int타입의 값에 대해 비트 이동을 할 때는 0~ 63 까지만 유효하다
    //    만약 63을 넘는 경우 64로 나눈 나머지 값을 비트 이동으로 간주한다.
    //
    // => 공식)
    //    n << s
    //    - n 이 int 타입이라면, 다음 계산을 통해 s의 최종 값을 결정한다.
    //      s & 0b11111 = 최종 비트 이동 값
    //      따라서 s의 값은 무조건 0 ~ 31이다.
    //      결국 s의 값은 s % 32의 결과와 같다.
    //
    //    - n 이 long 타입이라면, 다음 계산을 통해 s의 최종 값을 결정한다..
    //      s & 0b111111 = 최종 비트 이동 값
    //      따라서 s의 값은 무조건 0 ~ 63이다.
    //      결국 s의 값은 s % 64의 결과와 같다.
    // => 예1)
    //    3 << 33
    //    n = 00000000 00000000 00000000 00000011 = 3
    //    s = 00000000 00000000 00000000 00100001 = 33
    //    비트 이동 => s & 0b11111
    //          00000000 00000000 00000000 00100001 = 33
    //        & 00000000 00000000 00000000 00111111 =
    //         ---------------------------------------
    //          00000000 00000000 00000000 00000001 = 1
    //    최종 비트 이동 값을 계산하면 다음과 같다.
    //       3 << 33 == 3 << 1
    // => 예2)
    //    3 << 65
    //    n = 00000000 00000000 00000000 00000011 = 3
    //    s = 00000000 00000000 00000000 01000001 = 65
    //    비트 이동 => s & 0b11111
    //          00000000 00000000 00000000 01000001 = 65
    //        & 00000000 00000000 00000000 00111111 =
    //         ---------------------------------------
    //          00000000 00000000 00000000 00000001 = 1    
    //    최종 비트 이동 값을 계산하면 다음과 같다.
    //       3 << 65 == 3 << 1
    // 비트 이동 계산의 근거: Java 
    
  }
}
